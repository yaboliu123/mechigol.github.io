## Redis

1. Redis有哪些数据结构
    - String Hash List set SortSet
    - Bitmap HyperLogLog Stream GeoHash BloomFilter
2. Redis优缺点  
    - 优点：
        - 读写性能 -->高性能 高并发
        - 支持事务
        - 支持持久化
        - 数据结构丰富
        - 主从复制  
    - 缺点
        - 容量受到物理内存的限制
        - 难以在线扩容
        - 可能部分数据丢失
2. 速度快的原因
    1. 纯内存
    2. C语言
    3. 单线程
    4. IO多路复用
3. `Keys pattern` & `Scan cursor [pattern] [count]`
    - keys指令会导致线程阻塞一段时间，线上服务会停顿,不能线上服务
    - Scan渐进式 O(1)，如果键修改，导致新键没有遍历到，遍历出老键
4. Redis做异步队列
    - rpush生产消息，lpop消费消息，blpop，在没有消息的时候，它会阻塞住直到消息到来
5. 为什么要用pipeline?
    - 多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性
    - pipeline 不是原子性的
6. Redis pub/sub有什么缺点 
    - 数据可靠性无法保证, 发布者发送完消息便不管了
    - 扩展性太差 -- 不能通过增加消费者来加快消耗发布者的写入的数据，如果发布者发布的消息很多，则数据阻塞在通道中已等待被消费着来消耗
7. Redis如何实现延时队列？
    - 使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理
8. Redis持久化
    - RDB做镜像全量持久化，AOF做增量持久化
    - 用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态
9. 突然掉电？
    - 高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据
10. 是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么
    - **Redis Sentinal** 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。

    - **Redis Cluster** 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储
11. RDB原理
    - **fork和cow**。fork是指redis通过创建子进程来进行RDB操作，cow指的是*copy on write*，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来
12. Redis同步机制
    - Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog
13. 使用缓存会出现的问题？
    - 双写不一致
        - 常规: 删缓存，更新数据库
        - 高并发情况下的问题，可能会A删除缓存，B读取数据库旧值放入缓存，A更新数据库
        - 内存队列: 更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个jvm内部的队列中，读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个jvm内部的队列中  
        一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先执行删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成

    - 缓存雪崩  同时过期、宕机
        解决: 过期时间加随机值
    - 缓存穿透  
        - 布隆过滤器 提前拦截
        - 不存在的值 放在缓存，设定过期时间